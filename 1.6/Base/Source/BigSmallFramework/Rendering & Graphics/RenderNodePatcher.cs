using RimWorld;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using UnityEngine;
using Verse;
using static BigAndSmall.DefAltNamer;
using static Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetrics;

namespace BigAndSmall
{
    public static class RenderNodePatcher
    {
        public static List<ShaderTypeDef> DefaultPickableExtraShader =>
            field = GlobalSettings.AllAutoGeneratedShaderOptions;

        public static void TryUpdate(Dictionary<FlagString, HasCustomizableGraphics> dict, FlagString flag, List<FlagString> extraKeys)
        {
            if (!dict.TryGetValue(flag, out var existing))
            {
                existing = new HasCustomizableGraphics
                {
                    Flag = flag,
                    colorA = true,
                    colorB = true
                };
                dict[flag] = existing;
            }
            if (extraKeys != null)
            {
                existing.customFlags.AddRange(extraKeys);
            }
        }
        public static void TryPatchPawnRenderNodeDefs()
        {
            if (BigSmallMod.settings?.makeDefsRecolorable != true)
            {
                return;
            }
            var allGenes = DefDatabase<GeneDef>.AllDefsListForReading
                .Where(x=>!x.RenderNodeProperties.NullOrEmpty()
                && x.modExtensions?.Any(x=>x is HasCustomizableGraphics) != true
                && x.modExtensions?.Any(x => x is GraphicsOverride) != true
            );
            
            var allHediffs = DefDatabase<HediffDef>.AllDefsListForReading
                .Where(x => !x.RenderNodeProperties.NullOrEmpty()
                && x.modExtensions?.Any(x => x is HasCustomizableGraphics) != true
                && x.modExtensions?.Any(x => x is GraphicsOverride) != true
            );

            List<PawnRenderingProps_Lite> newNodes = [];

            FlagString hornGraphics = new("HornGraphics");
            FlagString earGraphics = new("EarGraphics");
            FlagString wingGraphics = new("WingGraphics");
            FlagString tailGraphics = new("TailGraphics");
            FlagString haloGraphics = new("HaloGraphics");
            FlagString miscHeadGraphics = new("MiscHeadGraphics");

            FlagString miscBodyGraphics = new("MiscBodyGraphics");
            FlagString headBionicGraphics = new("HeadBionicGraphics");
            FlagString bodyBionicGraphics = new("BodyBionicGraphics");
            FlagString headFleshGraphics = new("HeadFleshGraphics");
            FlagString bodyFleshGraphics = new("BodyFleshGraphics");

            foreach (var gene in allGenes)
            {
                Dictionary<FlagString, HasCustomizableGraphics> extensions = [];
                for (int idx = gene.RenderNodeProperties.Count - 1; idx >= 0; idx--)
                {
                    PawnRenderNodeProperties node = gene.RenderNodeProperties[idx];
                    string defName = gene.defName;
                    if (node.GetType() != typeof(PawnRenderNodeProperties))
                    {
                        // We only want to patch the exact type, not derived types, since those might have custom behavior,
                        // or expect properties we don't set here.
                        continue;
                    }
                    if (typeof(PawnRenderNode_Fur).IsAssignableFrom(node.nodeClass))
                    {
                        continue;
                    }
                    if (node.nodeClass == typeof(PawnRenderNode_AttachmentHead) || node.parentTagDef == PawnRenderNodeTagDefOf.Head)
                    {
                        if (
                            (gene.defName?.Contains("horn", StringComparison.OrdinalIgnoreCase) == true)
                            || (gene.exclusionTags?.Any(x => x.Contains("horn", StringComparison.OrdinalIgnoreCase)) == true)
                            || (gene.displayCategory?.defName?.Contains("horn", StringComparison.OrdinalIgnoreCase) == true)
                        )
                        {
                            var replacement = ReplaceWithLite(node, hornGraphics, gene, true, out List<FlagString> swapFlags);
                            TryUpdate(extensions, hornGraphics, swapFlags);
                            gene.RenderNodeProperties[idx] = replacement;
                            newNodes.Add(replacement);
                        }
                        else if (
                            (gene.defName?.Contains("ears", StringComparison.OrdinalIgnoreCase) == true)
                            || (gene.exclusionTags?.Any(x => x.Contains("ears", StringComparison.OrdinalIgnoreCase)) == true)
                            || (gene.displayCategory?.defName?.Contains("ears", StringComparison.OrdinalIgnoreCase) == true)
                        )
                        {
                            var replacement = ReplaceWithLite(node, earGraphics, gene, true, out List<FlagString> swapFlags);
                            TryUpdate(extensions, earGraphics, swapFlags);
                            gene.RenderNodeProperties[idx] = replacement;
                            newNodes.Add(replacement);
                        }
                        else if (
                            (gene.defName?.Contains("halo", StringComparison.OrdinalIgnoreCase) == true)
                            || (gene.exclusionTags?.Any(x => x.Contains("halo", StringComparison.OrdinalIgnoreCase)) == true)
                            || (gene.displayCategory?.defName?.Contains("halo", StringComparison.OrdinalIgnoreCase) == true)
                        )
                        {
                            var replacement = ReplaceWithLite(node, haloGraphics, gene, true, out List<FlagString> swapFlags);
                            TryUpdate(extensions, haloGraphics, swapFlags);
                            gene.RenderNodeProperties[idx] = replacement;
                            newNodes.Add(replacement);
                        }
                        else
                        {
                            var replacement = ReplaceWithLite(node, miscHeadGraphics, gene, true, out List<FlagString> swapFlags);
                            TryUpdate(extensions, miscHeadGraphics, swapFlags);
                            gene.RenderNodeProperties[idx] = replacement;
                            newNodes.Add(replacement);
                        }
                    }
                    else if (node.nodeClass == typeof(PawnRenderNode))
                    {
                        if (
                            (gene.defName?.Contains("wing", StringComparison.OrdinalIgnoreCase) == true)
                            || (gene.exclusionTags?.Any(x => x.Contains("wing", StringComparison.OrdinalIgnoreCase)) == true)
                            || (gene.displayCategory?.defName?.Contains("wing", StringComparison.OrdinalIgnoreCase) == true)
                        )
                        {
                            var replacement = ReplaceWithLite(node, wingGraphics, gene, true, out List<FlagString> swapFlags);
                            TryUpdate(extensions, wingGraphics, swapFlags);
                            gene.RenderNodeProperties[idx] = replacement;
                            newNodes.Add(replacement);
                        }
                        else if (
                            (gene.defName?.Contains("tail", StringComparison.OrdinalIgnoreCase) == true)
                            || (gene.exclusionTags?.Any(x => x.Contains("tail", StringComparison.OrdinalIgnoreCase)) == true)
                            || (gene.displayCategory?.defName?.Contains("tail", StringComparison.OrdinalIgnoreCase) == true)
                        )
                        {
                            var replacement = ReplaceWithLite(node, tailGraphics, gene, false, out List<FlagString> swapFlags);
                            TryUpdate(extensions, tailGraphics, swapFlags);
                            gene.RenderNodeProperties[idx] = replacement;
                            newNodes.Add(replacement);
                        }
                        else
                        {
                            var replacement = ReplaceWithLite(node, miscBodyGraphics, gene, false, out List<FlagString> swapFlags);
                            TryUpdate(extensions, miscBodyGraphics, swapFlags);
                            gene.RenderNodeProperties[idx] = replacement;
                            newNodes.Add(replacement);
                        }
                    }
                }
                foreach (var modExt in extensions.Values)
                {
                    gene.modExtensions ??= [];
                    gene.modExtensions.Add(modExt);
                }
            }
            foreach (var hediff in allHediffs)
            {
                Dictionary<FlagString, HasCustomizableGraphics> extensions = [];
                if (hediff.addedPartProps == null) continue;
                for (int idx = hediff.RenderNodeProperties.Count - 1; idx >= 0; idx--)
                {
                    PawnRenderNodeProperties node = hediff.RenderNodeProperties[idx];
                    if (node.GetType() != typeof(PawnRenderNodeProperties))
                    {
                        continue;
                    }
                    if (node.nodeClass == typeof(PawnRenderNode_AttachmentHead))
                    {
                        if (node.colorType == PawnRenderNodeProperties.AttachmentColorType.Custom)
                        {
                            var replacement = ReplaceWithLite(node, headBionicGraphics, hediff, true, out List<FlagString> swapFlags);
                            TryUpdate(extensions, headBionicGraphics, swapFlags);
                            hediff.RenderNodeProperties[idx] = replacement;
                            newNodes.Add(replacement);
                        }
                        else if (node.colorType == PawnRenderNodeProperties.AttachmentColorType.Skin)
                        {
                            var replacement = ReplaceWithLite(node, headFleshGraphics, hediff, true, out List<FlagString> swapFlags);
                            TryUpdate(extensions, headFleshGraphics, swapFlags);
                            hediff.RenderNodeProperties[idx] = replacement;
                            newNodes.Add(replacement);
                        }
                    }
                    else if (node.nodeClass == typeof(PawnRenderNode))
                    {
                        if (node.colorType == PawnRenderNodeProperties.AttachmentColorType.Custom)
                        {
                            var replacement = ReplaceWithLite(node, bodyBionicGraphics, hediff, true, out List<FlagString> swapFlags);
                            TryUpdate(extensions, bodyBionicGraphics, swapFlags);
                            hediff.RenderNodeProperties[idx] = replacement;
                            newNodes.Add(replacement);
                        }
                        else if (node.colorType == PawnRenderNodeProperties.AttachmentColorType.Skin)
                        {
                            var replacement = ReplaceWithLite(node, bodyFleshGraphics, hediff, true, out List<FlagString> swapFlags);
                            TryUpdate(extensions, bodyFleshGraphics, swapFlags);
                            hediff.RenderNodeProperties[idx] = replacement;
                            newNodes.Add(replacement);
                        }
                    }
                    foreach (var modExt in extensions.Values)
                    {
                        hediff.modExtensions ??= [];
                        hediff.modExtensions.Add(modExt);
                    }
                }
            }
            Log.Message($"[Big & Small] Patched {newNodes.Count} PawnRenderNodeProperties to use {nameof(PawnRenderingProps_Lite)} for recolorable graphics.\nRemember that you can always disable this again in the mod options.");
            foreach(var node in newNodes)
            {
                node.TrySetup(forceSetup: true);
                node.EnsureInitialized();
                node.ResolveReferencesRecursive();
            }
        }

        public static PawnRenderingProps_Lite ReplaceWithLite(PawnRenderNodeProperties original, FlagString tag, Def def, bool useHeadMesh, out List<FlagString> userPickableAlts)
        {
            var newProps = new PawnRenderingProps_Lite();
            var type = original.GetType();
            var fields = type.GetFields(System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public);// | System.Reflection.BindingFlags.NonPublic);
            var properties = type.GetProperties(System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public);// | System.Reflection.BindingFlags.NonPublic);
            foreach (var prop in properties)
            {
                if (prop.CanRead && prop.CanWrite)
                {
                    var value = prop.GetValue(original);
                    if (value == null || value == default) continue;
                    try
                    {
                        prop.SetValue(newProps, value);
                    }
                    catch (ArgumentException)
                    {
                        Log.WarningOnce($"[Big & Small] Failed to copy property {prop.Name} of type {prop.PropertyType} from {type} to {nameof(PawnRenderingProps_Lite)}. Skipping.", 2654322);
                    }
                }
            }

            foreach (var field in fields)
            {
                var value = field.GetValue(original);
                if (value == null || value == default) continue;
                try
                {
                    field.SetValue(newProps, value);
                }
                catch (ArgumentException)
                {
                    Log.WarningOnce($"[Big & Small] Failed to copy field {field.Name} of type {field.FieldType} from {type} to {nameof(PawnRenderingProps_Lite)}. Skipping.", 2654321);
                }
            }

            newProps.tag = tag;
            newProps.nodeClass = typeof(RenderNodeLite);
            newProps.useHeadMesh = useHeadMesh;
            if (original.shaderTypeDef == null || original.shaderTypeDef == ShaderTypeDefOf.Cutout)
            {
                newProps.shader = ShaderTypeDefOf.Cutout;
            }
            else
            {
                newProps.shader = original.shaderTypeDef;
            }
            newProps.identifier = def.defName;

            var userFlags = new List<FlagString>();
            foreach(var shaderType in DefaultPickableExtraShader)
            {
                var newFlag = new FlagString(def.defName, shaderType.defName)
                {
                    Label = tag.Label.CapitalizeFirst() + " -> " + shaderType.label
                };
                userFlags.Add(newFlag);
                newProps.userPickableShaders.Add(shaderType);
            }
            userPickableAlts = userFlags;

            return newProps;
        }
    }
}
